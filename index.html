<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=0.8, user-scalable=yes" />
  <title>ethernAI — Snake Game</title>
  <style>
    :root{
      --bg:#0a0e14;
      --panel:#10151e;
      --accent:#2563eb;
      --accent2:#3b82f6;
      --tech-blue:#0ea5e9;
      --tech-purple:#8b5cf6;
      --text:#e6eef6;
      --muted:#94a3b8;
      --radius:14px;
      --snake-color:#22d3ee;
      --food-color:#ef4444;
    }
    *{box-sizing:border-box} 
    
    body{
      margin:0;
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      background: 
        radial-gradient(circle at 10% 10%, #05070a, #080b10 20%, #090d12 40%, #0a0e14),
        radial-gradient(circle at 90% 80%, #070a0d, #080b0f 30%, #090c10 60%, #0a0e14);
      color:var(--text);
      touch-action:manipulation;
      overflow-x:auto; 
      min-height:100vh;
      position: relative;
    }
    
    /* Efecto de líneas de conexión tecnológicas */
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        linear-gradient(90deg, transparent 98%, rgba(14, 165, 233, 0.1) 99%),
        linear-gradient(0deg, transparent 98%, rgba(14, 165, 233, 0.1) 99%);
      background-size: 30px 30px;
      pointer-events: none;
      z-index: -1;
    }
    
    /* Efecto de partículas tecnológicas */
    body::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 30%, rgba(14, 165, 233, 0.05) 0%, transparent 60%),
        radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.05) 0%, transparent 60%),
        radial-gradient(circle at 40% 70%, rgba(37, 99, 235, 0.05) 0%, transparent 60%);
      pointer-events: none;
      z-index: -1;
    }
    
    header{position:sticky;top:0;background:rgba(10,14,20,.85);backdrop-filter:blur(6px);border-bottom:1px solid rgba(255,255,255,.03);z-index:10}
    .container{max-width:1100px;margin:0 auto;padding:20px}
    .nav{display:flex;align-items:center;gap:12px}
    .brand{display:flex;gap:12px;align-items:center}
    .logo {
        width: 220px;
        height: 60px;
        border-radius: 10px;
        background-image: url('https://raw.githubusercontent.com/Antoin3e/E3thernAI/main/ETHERNAILOGO.png');
        background-size: cover;
        background-position: center;
        box-shadow: 0 6px 26px rgba(37, 99, 235, .12);
    }
    .tabs{margin-left:auto;display:flex;gap:8px}
    .tab{background:transparent;border:0;padding:8px 12px;color:var(--muted);cursor:pointer;border-radius:10px;font-weight:700}
    .tab.active{color:var(--text);background:linear-gradient(180deg,rgba(37,99,235,.06),rgba(37,99,235,.03))}
    main{padding:20px}
    .panel{display:none;background:linear-gradient(180deg, rgba(255,255,255,.01), rgba(255,255,255,0));border:1px solid rgba(255,255,255,.03); border-radius:var(--radius); padding:18px; box-shadow:0 10px 30px rgba(0,0,0,.45)}
    .panel.active{display:block}

    /* Game layout */
    .game-wrap{display:grid;grid-template-columns:1fr;gap:16px}
    @media(max-width:980px){
      .game-wrap{grid-template-columns:1fr}
      .tabs{display:none}
      .mobile-tabs{display:flex;justify-content:space-around;margin:20px 0;background:rgba(255,255,255,.02);border-radius:12px;padding:8px}
      .mobile-tab{color:var(--muted);padding:10px;text-align:center;flex:1;font-weight:700}
      .mobile-tab.active{color:var(--text);background:linear-gradient(180deg,rgba(37,99,235,.06),rgba(37,99,235,.03));border-radius:8px}
      
      /* Ajustes para móvil */
      #panel-datos, #panel-catalogo {
        transform: scale(0.95);
        transform-origin: top center;
        width: 100%;
        margin-left: 0;
        overflow-x: auto;
      }
      
      /* Permitir zoom y desplazamiento en móviles */
      body {
        touch-action: manipulation;
        overflow-x: auto;
      }
      
      .container, main {
        width: 100%;
        max-width: 100%;
        overflow-x: auto;
      }
    }
    @media(max-width:768px){
      .container{padding:10px}
      main{padding:10px}
      .kpis{grid-template-columns:repeat(2,1fr) !important}
      .catalog{grid-template-columns:1fr !important}
      .data-grid{grid-template-columns:1fr !important}
      
      /* Ajustes adicionales para móviles pequeños */
      #panel-datos, #panel-catalogo {
        transform: scale(0.9);
        width: 110%;
        margin-left: -5%;
      }
      
      /* Mejorar visualización de tablas en móvil */
      table {
        font-size: 12px;
      }
      
      th, td {
        padding: 6px 4px;
      }
    }
    @media(min-width:981px){
      .mobile-tabs{display:none}
    }
    canvas#game{width:100%;height:480px;border-radius:12px;background:linear-gradient(180deg,#0d1117,#0a0e14);display:block;border:1px solid rgba(255,255,255,.03)}
    .hud{display:none} /* Ocultamos el panel lateral */
    .stat{display:flex;justify-content:space-between;padding:8px 10px;border-radius:8px;background:rgba(255,255,255,.02);margin-bottom:8px}
    .btn{appearance:none;border:0;padding:10px 12px;border-radius:10px;background:linear-gradient(180deg,var(--accent),var(--accent2));color:#041018;font-weight:800;cursor:pointer}
    .btn-secondary{appearance:none;border:0;padding:10px 12px;border-radius:10px;background:linear-gradient(180deg, #6366f1, #4f46e5);color:white;font-weight:800;cursor:pointer;margin-top:10px}

    /* Registration overlay */
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:5;background:rgba(6,8,12,.85)}
    .card{background:var(--panel);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,.04);min-width:320px;max-width:90vw}
    .field{display:flex;flex-direction:column;margin-bottom:10px}
    .field input{padding:10px;border-radius:8px;background:#071018;border:1px solid rgba(255,255,255,.03);color:var(--text)}

    /* Data */
    .kpis{display:grid;grid-template-columns:repeat(4,1fr);gap:12px;margin-bottom:12px}
    .kpi{background:rgba(255,255,255,.02);padding:10px;border-radius:10px;text-align:center;border:1px solid rgba(255,255,255,.03)}
    table{width:100%;border-collapse:collapse;border-radius:10px;overflow:hidden}
    th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,.03);text-align:left}
    .data-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-top:12px}
    .charts-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-top:20px}
    .full-width{grid-column:1/-1}

    /* Catalog */
    .catalog{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    .cat{background:linear-gradient(180deg,rgba(37,99,235,.04),rgba(59,130,246,.03));padding:12px;border-radius:12px;cursor:pointer;border:1px solid rgba(255,255,255,.03)}
    .contact{margin-top:10px;padding:8px;background:rgba(0,0,0,.3);border-radius:8px;border:1px solid rgba(255,255,255,.03)}

    /* Joystick */
    #joystick-container{position:absolute;bottom:20px;left:20px;width:120px;height:120px;z-index:4;display:none}
    #joystick{width:100%;height:100%;border-radius:50%;background:rgba(37,99,235,0.1);border:1px solid rgba(255,255,255,0.1);position:relative}
    #joystick-handle{width:40px;height:40px;border-radius:50%;background:linear-gradient(180deg,var(--accent),var(--accent2));position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);touch-action:none}

    /* Botón de menú para móvil */
    .mobile-menu-btn{display:none;background:transparent;border:none;color:var(--muted);font-size:24px;cursor:pointer;padding:5px}
    @media(max-width:980px){
      .mobile-menu-btn{display:block}
      .tabs{display:none;position:absolute;top:100%;right:0;background:rgba(10,14,20,.9);backdrop-filter:blur(6px);flex-direction:column;width:200px;border-radius:12px;padding:10px;border:1px solid rgba(255,255,255,.03);z-index:10}
      .tabs.active{display:flex}
      .tab{width:100%;text-align:left;margin-bottom:5px}
    }
    
    /* Mejoras para visualización en móvil */
    .mobile-optimized {
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }
    
    /* Permitir zoom en contenido */
    .zoomable {
      max-width: 100%;
      overflow: auto;
    }
    
    /* Mini HUD dentro del juego */
    .mini-hud {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: bold;
      z-index: 3;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    /* Logos redes sociales */
    .social-logos {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 15px;
    }
    
    .social-logo {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s;
      background-size: cover;
      background-position: center;
    }
    
    .social-logo:hover {
      transform: scale(1.1);
      box-shadow: 0 0 10px var(--tech-blue);
    }
    
    /* Logos específicos */
    .facebook-logo {
      background-image: url('https://upload.wikimedia.org/wikipedia/commons/5/51/Facebook_f_logo_%282019%29.svg');
    }
    
    .instagram-logo {
      background-image: url('https://upload.wikimedia.org/wikipedia/commons/9/95/Instagram_logo_2022.svg');
    }
    
    .linkedin-logo {
      background-image: url('https://upload.wikimedia.org/wikipedia/commons/c/ca/LinkedIn_logo_initials.png');
      background-color: white;
    }
    
    .youtube-logo {
      background-image: url('https://upload.wikimedia.org/wikipedia/commons/0/09/YouTube_full-color_icon_%282017%29.svg');
    }
    
    /* Indicadores de estadísticas en tiempo real */
    .stats-container {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
      background: rgba(255, 255, 255, 0.02);
      padding: 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.03);
    }
    
    .stat-item {
      text-align: center;
    }
    
    .stat-value {
      font-size: 18px;
      font-weight: bold;
      color: var(--tech-blue);
    }
    
    .stat-label {
      font-size: 12px;
      color: var(--muted);
    }
  </style>
</head>
<body class="mobile-optimized">
  <header>
    <div class="container nav">
      <div class="brand"><div class="logo"></div><div>
        <div style="font-weight:800">ethernAI</div>
        <div style="font-size:12px;color:var(--muted)">Soluciones Industria 4.0 · IA · Big Data</div>
      </div></div>
      <button class="mobile-menu-btn">☰</button>
      <div class="tabs">
        <button class="tab active" data-tab="jugar">Jugar</button>
        <button class="tab" data-tab="datos">Datos</button>
        <button class="tab" data-tab="catalogo">Catálogo</button>
      </div>
    </div>
  </header>

  <main class="container zoomable">
    <!-- Mobile tabs -->
    <div class="mobile-tabs">
      <div class="mobile-tab active" data-tab="jugar">Jugar</div>
      <div class="mobile-tab" data-tab="datos">Datos</div>
      <div class="mobile-tab" data-tab="catalogo">Catálogo</div>
    </div>

    <!-- JUGAR -->
    <section id="panel-jugar" class="panel active">
      <h1>JUEGA: SNAKE</h1>
      <p style="color:var(--muted)">Controla la serpiente (WASD / flechas) o inclina tu móvil. Cada comida te da 10 puntos. Evita chocar contra las paredes o contra ti mismo.</p>

      <div class="stats-container">
        <div class="stat-item">
          <div class="stat-value" id="current-score">0</div>
          <div class="stat-label">PUNTOS</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="food-eaten">0</div>
          <div class="stat-label">COMIDAS</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="game-time">0s</div>
          <div class="stat-label">TIEMPO</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="snake-length">3</div>
          <div class="stat-label">LONGITUD</div>
        </div>
      </div>

      <div class="game-wrap">
        <div style="position:relative">
          <canvas id="game" width="900" height="480"></canvas>
          
          <!-- Mini HUD dentro del juego -->
          <div class="mini-hud">
            Puntaje: <span id="mini-score">0</span>
          </div>
          
          <!-- Joystick para móvil -->
          <div id="joystick-container">
            <div id="joystick">
              <div id="joystick-handle"></div>
            </div>
          </div>

          <div id="overlayReg" class="overlay">
            <div class="card">
              <h2>Registrate para comenzar</h2>
              <p class="note" style="color:var(--muted);margin:6px 0">Antes de cada partida registra Nombre, Teléfono y Edad.</p>
              <div class="field"><label>Nombre</label><input id="name" placeholder="Tu nombre" maxlength="40"></div>
              <div class="field"><label>Teléfono</label><input id="phone" placeholder="Ingresa tu numero de telefono" maxlength="20" inputmode="tel"></div>
              <div class="field"><label>Edad</label><input id="age" type="number" min="5" max="120"></div>
              <div style="display:flex;gap:8px;margin-top:6px;align-items:center;flex-wrap:wrap">
                <button id="btnStart" class="btn">Comenzar</button>
                <button id="btnGyro" class="btn" style="background:linear-gradient(180deg,#fff3 10%,rgba(255,255,255,.02));color:var(--text);font-weight:700">Permitir Giroscopio</button>
              </div>
              <p style="font-size:12px;color:var(--muted);margin-top:8px">Los datos se guardan localmente en tu navegador.</p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- DATOS -->
    <section id="panel-datos" class="panel">
      <h1>Dashboard de jugadores</h1>
      <div class="kpis" id="kpis"></div>

      <div class="data-grid">
        <div>
          <table>
            <thead><tr><th>Nombre</th><th>Teléfono</th><th>Edad</th><th>Mejor</th><th>Partidas</th><th>Puntos/s</th><th>Tiempo(s)</th><th>Comidas</th><th>Última</th></tr></thead>
            <tbody id="rows"></tbody>
          </table>
        </div>
        <div style="background:rgba(255,255,255,.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,.03)">
          <h3 style="margin:0 0 8px">Distribución de edades</h3>
          <canvas id="ageChart" width="380" height="260"></canvas>
          <h3 style="margin-top:12px">Top 5 mejores puntajes</h3>
          <ol id="topList" style="color:var(--muted)"></ol>
        </div>
      </div>

      <div class="charts-grid">
        <div style="background:rgba(255,255,255,.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,.03)">
          <h3 style="margin:0 0 8px">Distribución de puntajes</h3>
          <canvas id="scoreChart" width="380" height="260"></canvas>
        </div>
        <div style="background:rgba(255,255,255,.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,.03)">
          <h3 style="margin:0 0 8px">Comidas por minuto</h3>
          <canvas id="foodPerMinChart" width="380" height="260"></canvas>
        </div>
      </div>

      <div class="charts-grid">
        <div style="background:rgba(255,255,255,.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,.03)">
          <h3 style="margin:0 0 8px">Eficiencia por grupo de edad</h3>
          <canvas id="efficiencyChart" width="380" height="260"></canvas>
        </div>
        <div style="background:rgba(255,255,255,.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,.03)">
          <h3 style="margin:0 0 8px">Duración promedio de partidas</h3>
          <canvas id="durationChart" width="380" height="260"></canvas>
        </div>
      </div>

      <div style="margin-top:20px;text-align:center">
        <button id="clearDataBtn" class="btn-secondary">🗑️ Limpiar todos los datos</button>
        <p style="color:var(--muted);font-size:12px;margin-top:8px">Esta acción eliminará todos los registros de jugadores y no se puede deshacer.</p>
      </div>
    </section>

    <!-- CATALOGO -->
    <section id="panel-catalogo" class="panel">
      <h1>Catálogo de soluciones</h1>
      <p style="color:var(--muted)">Presiona una tarjeta para ver nuestro contacto.</p>
      <div class="catalog">
        <div class="cat" data-title="Optimización de flujos" onclick="showContact(this)">
          <h3>Optimización de flujos operativos</h3>
          <p style="color:var(--muted)">Mapeo, automatización y reducción de tiempos ciclo.</p>
        </div>
        <div class="cat" data-title="Inventarios" onclick="showContact(this)">
          <h3>Gestión inteligente de inventarios</h3>
          <p style="color:var(--muted)">Forecasting con IA para disminuir faltantes y sobrestock.</p>
        </div>
        <div class="cat" data-title="Mantenimiento" onclick="showContact(this)">
          <h3>Mantenimiento predictivo</h3>
          <p style="color:var(--muted)">Modelos de falla y monitoreo de condición.</p>
        </div>
        <div class="cat" data-title="Analitica" onclick="showContact(this)">
          <h3>Analítica y dashboards</h3>
          <p style="color:var(--muted)">Dashboards accionables y DataOps.</p>
        </div>
        <div class="cat" data-title="Automatizacion" onclick="showContact(this)">
          <h3>Automatización documental</h3>
          <p style="color:var(--muted)">OCR y workflows sin papel.</p>
        </div>
        <div class="cat" data-title="Integracion" onclick="showContact(this)">
          <h3>Integración de datos</h3>
          <p style="color:var(--muted)">Conexión de fuentes y APIs para BI.</p>
        </div>
      </div>
      
      <!-- Logos de redes sociales -->
      <div class="social-logos">
        <div class="social-logo facebook-logo" onclick="window.open('https://www.facebook.com/people/Ethern-AI/61558213730936/', '_blank')"></div>
        <div class="social-logo instagram-logo" onclick="window.open('https://www.instagram.com/ethern_ai?igsh=MTNjc3B1b2RqZGpwNg==', '_blank')"></div>
        <div class="social-logo linkedin-logo" onclick="window.open('https://www.linkedin.com/company/ethern-ai/', '_blank')"></div>
        <div class="social-logo youtube-logo" onclick="window.open('https://www.youtube.com/@Ethern-ai', '_blank')"></div>
      </div>
    </section>

  </main>

  <script>
    /* ===== Navegación de pestañas ===== */
    const tabs = document.querySelectorAll('.tab');
    const mobileTabs = document.querySelectorAll('.mobile-tab');
    const panels = {jugar:document.getElementById('panel-jugar'), datos:document.getElementById('panel-datos'), catalogo:document.getElementById('panel-catalogo')};
    const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
    const clearDataBtn = document.getElementById('clearDataBtn');
    const miniScoreEl = document.getElementById('mini-score');
    
    function activateTab(tabName) {
      tabs.forEach(b => b.classList.remove('active'));
      mobileTabs.forEach(b => b.classList.remove('active'));
      document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');
      document.querySelector(`.mobile-tab[data-tab="${tabName}"]`).classList.add('active');
      
      Object.values(panels).forEach(p => p.classList.remove('active'));
      panels[tabName].classList.add('active');
      
      // Cerrar menú móvil si está abierto
      document.querySelector('.tabs').classList.remove('active');
      
      if(tabName === 'datos') renderDashboard();
    }
    
    tabs.forEach(t => t.addEventListener('click', () => activateTab(t.dataset.tab)));
    mobileTabs.forEach(t => t.addEventListener('click', () => activateTab(t.dataset.tab)));
    
    // Toggle menú móvil
    mobileMenuBtn.addEventListener('click', () => {
      document.querySelector('.tabs').classList.toggle('active');
    });

    // Cerrar menú al hacer clic fuera
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.tabs') && !e.target.closest('.mobile-menu-btn')) {
        document.querySelector('.tabs').classList.remove('active');
      }
    });

    /* ===== Persistencia ===== */
    const LS = 'ethernai_players_v1';
    function load(){ try{return JSON.parse(localStorage.getItem(LS))||[];}catch{return [];} }
    function save(data){ localStorage.setItem(LS, JSON.stringify(data)); }

    // Limpiar datos
    clearDataBtn.addEventListener('click', () => {
      if(confirm('¿Estás seguro de que quieres eliminar todos los datos? Esta acción no se puede deshacer.')) {
        localStorage.removeItem(LS);
        players = [];
        renderDashboard();
        alert('Todos los datos han sido eliminados.');
      }
    });

    /* ====== Juego Snake (canvas) ====== */
    const canvas = document.getElementById('game'); 
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlayReg');
    const nameIn = document.getElementById('name'); 
    const phoneIn = document.getElementById('phone'); 
    const ageIn = document.getElementById('age');
    const btnStart = document.getElementById('btnStart'); 
    const btnGyro = document.getElementById('btnGyro');

    let players = load(); 
    let current = null; 
    let running = false; 
    let raf = null; 
    let world = {w: canvas.width, h: canvas.height};
    
    // Variables del juego Snake
    const gridSize = 20;
    let snake = [];
    let food = {};
    let direction = 'right';
    let nextDirection = 'right';
    let score = 0;
    let gameSpeed = 7; // Velocidad más lenta
    let frameCount = 0;
    let gameOver = false;
    let maxLength = 0;
    let startTime = 0;
    let sessionCounted = false;
    let gyroEnabled = false; 
    let tiltX = 0; 
    let joystickActive = false; 
    let joystickX = 0; 
    let joystickY = 0;
    let foodEaten = 0;
    let gameTimer = null;

    // Elementos de estadísticas en tiempo real
    const currentScoreEl = document.getElementById('current-score');
    const foodEatenEl = document.getElementById('food-eaten');
    const gameTimeEl = document.getElementById('game-time');
    const snakeLengthEl = document.getElementById('snake-length');

    // Detectar dispositivo móvil
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    if (isMobile) {
      document.getElementById('joystick-container').style.display = 'block';
    }

    // Inicializar joystick si es móvil
    if (isMobile) {
      initJoystick();
    }

    // make canvas responsive - Versión mejorada
    window.addEventListener('resize', () => {
      const r = canvas.getBoundingClientRect();
      
      if (Math.abs(r.width - world.w) > 10) {
        world.w = canvas.width = r.width;
        world.h = canvas.height = 480;
        
        // Reiniciar el juego si está corriendo
        if (running) {
          resetGame();
        }
        
        draw();
      }
    });

    // Inicializar joystick
    function initJoystick() {
      const joystick = document.getElementById('joystick');
      const handle = document.getElementById('joystick-handle');
      const joystickSize = joystick.offsetWidth;
      const handleSize = handle.offsetWidth;
      const maxDistance = (joystickSize - handleSize) / 2;

      let touchId = null;

      handle.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchId = e.changedTouches[0].identifier;
        joystickActive = true;
      });

      document.addEventListener('touchmove', (e) => {
        if (!joystickActive) return;
        
        const touch = Array.from(e.changedTouches).find(t => t.identifier === touchId);
        if (!touch) return;
        
        const rect = joystick.getBoundingClientRect();
        const centerX = rect.left + joystickSize / 2;
        const centerY = rect.top + joystickSize / 2;
        
        let x = touch.clientX - centerX;
        let y = touch.clientY - centerY;
        
        // Limitar el movimiento al área del joystick
        const distance = Math.min(maxDistance, Math.sqrt(x * x + y * y));
        const angle = Math.atan2(y, x);
        
        x = Math.cos(angle) * distance;
        y = Math.sin(angle) * distance;
        
        // Actualizar posición del handle
        handle.style.transform = `translate(${x}px, ${y}px)`;
        
        // Calcular valores normalizados para el movimiento
        joystickX = x / maxDistance;
        joystickY = y / maxDistance;
        
        // Determinar dirección basada en el joystick
        if (Math.abs(joystickX) > Math.abs(joystickY)) {
          if (joystickX > 0.3 && direction !== 'left') nextDirection = 'right';
          else if (joystickX < -0.3 && direction !== 'right') nextDirection = 'left';
        } else {
          if (joystickY > 0.3 && direction !== 'up') nextDirection = 'down';
          else if (joystickY < -0.3 && direction !== 'down') nextDirection = 'up';
        }
      });

      document.addEventListener('touchend', (e) => {
        if (!joystickActive) return;
        
        const touch = Array.from(e.changedTouches).find(t => t.identifier === touchId);
        if (!touch) return;
        
        // Resetear joystick
        handle.style.transform = 'translate(-50%, -50%)';
        joystickX = 0;
        joystickY = 0;
        joystickActive = false;
        touchId = null;
      });
    }

    // controles teclado
    window.addEventListener('keydown', e => { 
      // Solo capturar teclas de movimiento si no estamos en un campo de texto
      if (!['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
        switch(e.code) {
          case 'ArrowUp':
          case 'KeyW':
            if (direction !== 'down') nextDirection = 'up';
            e.preventDefault();
            break;
          case 'ArrowDown':
          case 'KeyS':
            if (direction !== 'up') nextDirection = 'down';
            e.preventDefault();
            break;
          case 'ArrowLeft':
          case 'KeyA':
            if (direction !== 'right') nextDirection = 'left';
            e.preventDefault();
            break;
          case 'ArrowRight':
          case 'KeyD':
            if (direction !== 'left') nextDirection = 'right';
            e.preventDefault();
            break;
        }
      }
    });

    // giroscopio (movimiento lateral)
    btnGyro.addEventListener('click', async ()=>{
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission === 'granted') {
            window.addEventListener('deviceorientation', onDeviceOrientation);
            gyroEnabled = true;
            alert('Giroscopio activado. Inclina tu dispositivo para controlar la serpiente.');
          } else {
            alert('Permiso para usar el giroscopio denegado.');
          }
        } catch (error) {
          alert('Error al solicitar permiso para el giroscopio: ' + error.message);
        }
      } else if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', onDeviceOrientation);
        gyroEnabled = true;
        alert('Giroscopio activado. Inclina tu dispositivo para controlar la serpiente.');
      } else {
        alert('Tu dispositivo no soporta el API de orientación o no está disponible.');
      }
    });

    function onDeviceOrientation(e) {
      // Gamma es la inclinación izquierda-derecha
      // Beta es la inclinación adelante-atrás
      if (e.gamma !== null && e.beta !== null) {
        // Determinar dirección basada en la inclinación
        if (Math.abs(e.gamma) > Math.abs(e.beta)) {
          if (e.gamma > 15 && direction !== 'left') nextDirection = 'right';
          else if (e.gamma < -15 && direction !== 'right') nextDirection = 'left';
        } else {
          if (e.beta > 15 && direction !== 'up') nextDirection = 'down';
          else if (e.beta < -15 && direction !== 'down') nextDirection = 'up';
        }
      }
    }

    function spawnFood() {
      const cols = Math.floor(world.w / gridSize);
      const rows = Math.floor(world.h / gridSize);
      
      let validPosition = false;
      while (!validPosition) {
        food = {
          x: Math.floor(Math.random() * cols) * gridSize,
          y: Math.floor(Math.random() * rows) * gridSize
        };
        
        // Verificar que la comida no esté en la serpiente
        validPosition = true;
        for (let i = 0; i < snake.length; i++) {
          if (snake[i].x === food.x && snake[i].y === food.y) {
            validPosition = false;
            break;
          }
        }
      }
    }

    function resetGame() {
      // Inicializar serpiente
      snake = [
        {x: 5 * gridSize, y: 10 * gridSize},
        {x: 4 * gridSize, y: 10 * gridSize},
        {x: 3 * gridSize, y: 10 * gridSize}
      ];
      
      direction = 'right';
      nextDirection = 'right';
      score = 0;
      foodEaten = 0;
      maxLength = 3;
      gameSpeed = 7; // Velocidad más lenta
      frameCount = 0;
      gameOver = false;
      miniScoreEl.textContent = score;
      currentScoreEl.textContent = score;
      foodEatenEl.textContent = foodEaten;
      snakeLengthEl.textContent = snake.length;
      gameTimeEl.textContent = '0s';
      
      spawnFood();
    }

    // CORRECCIÓN: Añadir event listener al botón de comenzar
    btnStart.addEventListener('click', ()=>{
      const name = nameIn.value.trim(); 
      const phone = phoneIn.value.trim(); 
      const age = parseInt(ageIn.value,10);
      if(!name || !phone || !age || age < 5 || age > 120){ 
        alert('Ingresa nombre, teléfono y edad válidos.'); 
        return; 
      }
      current = {
        name, 
        phone, 
        age, 
        sessions: 0, 
        best: 0, 
        totalTime: 0, 
        totalFood: 0,
        foodPerMin: 0,
        pointsPerSec: 0,
        last: new Date().toISOString()
      };
      overlay.style.display = 'none'; 
      resetGame(); 
      startGame();
    });

    function startGame(){ 
      if(running) return; 
      running = true; 
      startTime = Date.now();
      sessionCounted = true; 
      
      // Iniciar temporizador para mostrar el tiempo de juego
      let seconds = 0;
      gameTimer = setInterval(() => {
        seconds++;
        gameTimeEl.textContent = seconds + 's';
      }, 1000);
      
      loop(); 
    }

    function endGame(justReset = false){ 
      running = false; 
      cancelAnimationFrame(raf); 
      raf = null; 
      clearInterval(gameTimer);
      
      const timeSec = Math.floor((Date.now() - startTime) / 1000);
      const pointsPerSec = timeSec > 0 ? (score / timeSec).toFixed(2) : 0;
      const foodPerMin = timeSec > 0 ? ((foodEaten / timeSec) * 60).toFixed(2) : 0;
      
      // guardar datos
      if(current){ 
        current.sessions = (current.sessions || 0) + 1; 
        current.totalTime = (current.totalTime || 0) + timeSec; 
        current.totalFood = (current.totalFood || 0) + foodEaten;
        current.pointsPerSec = pointsPerSec;
        current.foodPerMin = foodPerMin;
        current.last = new Date().toISOString(); 
        
        if(score > (current.best || 0)){ 
          current.best = score; 
        }
        
        // merge into players
        const idx = players.findIndex(p => 
          p.name.toLowerCase() === current.name.toLowerCase() && p.phone === current.phone
        );
        
        if(idx >= 0){ 
          const p = players[idx]; 
          p.sessions = current.sessions; 
          p.totalTime = current.totalTime; 
          p.totalFood = current.totalFood;
          p.pointsPerSec = current.pointsPerSec;
          p.foodPerMin = current.foodPerMin;
          p.best = Math.max(p.best || 0, current.best); 
          p.scores = p.scores || []; 
          p.scores.push(score); 
          p.last = current.last;
        } else { 
          current.scores = [score]; 
          players.push(current); 
        }
        
        save(players);
      }
      
      // mostrar popup resumen si no es solo reinicio
      if(!justReset){ 
        alert(`Partida finalizada. 
Puntaje: ${score} 
Comidas: ${foodEaten}
Tiempo: ${timeSec}s
Puntos por segundo: ${pointsPerSec}
Comidas por minuto: ${foodPerMin}`);
      }
      
      // exigir re-registro para jugar otra vez
      overlay.style.display = 'flex'; 
      current = null;
    }

    function loop(){ 
      update(); 
      draw(); 
      if(running) raf = requestAnimationFrame(loop); 
    }

    function update(){ 
      frameCount++;
      
      // Actualizar dirección
      direction = nextDirection;
      
      // Mover la serpiente cada X frames según la velocidad del juego
      if (frameCount % Math.floor(20 / gameSpeed) !== 0) return;
      
      // Mover la serpiente
      const head = {x: snake[0].x, y: snake[0].y};
      
      switch(direction) {
        case 'up': head.y -= gridSize; break;
        case 'down': head.y += gridSize; break;
        case 'left': head.x -= gridSize; break;
        case 'right': head.x += gridSize; break;
      }
      
      // Detectar colisiones con los bordes
      if (head.x < 0 || head.x >= world.w || head.y < 0 || head.y >= world.h) {
        gameOver = true;
        endGame(false);
        return;
      }
      
      // Detectar colisiones consigo misma
      for (let i = 0; i < snake.length; i++) {
        if (snake[i].x === head.x && snake[i].y === head.y) {
          gameOver = true;
          endGame(false);
          return;
        }
      }
      
      // Añadir nueva cabeza
      snake.unshift(head);
      
      // Comprobar si come la comida
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        foodEaten++;
        maxLength = Math.max(maxLength, snake.length);
        miniScoreEl.textContent = score;
        currentScoreEl.textContent = score;
        foodEatenEl.textContent = foodEaten;
        snakeLengthEl.textContent = snake.length;
        spawnFood();
      } else {
        // Quitar cola si no ha comido
        snake.pop();
      }
    }

    function draw(){ 
      ctx.clearRect(0, 0, world.w, world.h);
      
      // Dibujar grid
      ctx.strokeStyle = 'rgba(14, 165, 233, 0.1)'; 
      ctx.lineWidth = 1; 
      for(let x = 0; x < world.w; x += gridSize){ 
        ctx.beginPath(); 
        ctx.moveTo(x, 0); 
        ctx.lineTo(x, world.h); 
        ctx.stroke(); 
      }
      
      for(let y = 0; y < world.h; y += gridSize){ 
        ctx.beginPath(); 
        ctx.moveTo(0, y); 
        ctx.lineTo(world.w, y); 
        ctx.stroke(); 
      }
      
      // Dibujar comida
      ctx.fillStyle = '#ef4444';
      ctx.beginPath();
      ctx.arc(food.x + gridSize/2, food.y + gridSize/2, gridSize/2 - 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Dibujar serpiente
      for (let i = 0; i < snake.length; i++) {
        const part = snake[i];
        
        // Cabeza con color diferente
        if (i === 0) {
          ctx.fillStyle = '#0ea5e9';
        } else {
          // Degradado de color a lo largo del cuerpo
          const colorValue = Math.floor(150 + (100 * i / snake.length));
          ctx.fillStyle = `rgb(34, 211, ${colorValue})`;
        }
        
        ctx.fillRect(part.x, part.y, gridSize - 1, gridSize - 1);
        
        // Ojos en la cabeza
        if (i === 0) {
          ctx.fillStyle = '#000';
          const eyeSize = gridSize / 5;
          
          // Posición de los ojos según la dirección
          let eyeX1, eyeY1, eyeX2, eyeY2;
          
          switch(direction) {
            case 'up':
              eyeX1 = part.x + gridSize/3;
              eyeY1 = part.y + gridSize/3;
              eyeX2 = part.x + 2*gridSize/3;
              eyeY2 = part.y + gridSize/3;
              break;
            case 'down':
              eyeX1 = part.x + gridSize/3;
              eyeY1 = part.y + 2*gridSize/3;
              eyeX2 = part.x + 2*gridSize/3;
              eyeY2 = part.y + 2*gridSize/3;
              break;
            case 'left':
              eyeX1 = part.x + gridSize/3;
              eyeY1 = part.y + gridSize/3;
              eyeX2 = part.x + gridSize/3;
              eyeY2 = part.y + 2*gridSize/3;
              break;
            case 'right':
              eyeX1 = part.x + 2*gridSize/3;
              eyeY1 = part.y + gridSize/3;
              eyeX2 = part.x + 2*gridSize/3;
              eyeY2 = part.y + 2*gridSize/3;
              break;
          }
          
          ctx.beginPath();
          ctx.arc(eyeX1, eyeY1, eyeSize, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(eyeX2, eyeY2, eyeSize, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    // catálogo contact
    window.showContact = function(el){ 
      if(el.querySelector('.contact')) return; 
      const d = document.createElement('div'); 
      d.className = 'contact'; 
      d.innerHTML = 'Tel: <strong>8123836266</strong><br>Email: <strong>thisis.ethernai@gmail.com</strong><br><br>Pagina Web: <a href="https://thisisakkuanet-netizen.github.io/AKKUA/#home" target="_blank">Ethern-ai</a>';
      el.appendChild(d); 
    }

    // Dashboard
    function renderDashboard(){ 
      const list = load(); 
      const kpis = document.getElementById('kpis'); 
      
      if(!list.length){ 
        kpis.innerHTML = '<div style="grid-column:1/-1;color:var(--muted)">No hay registros aún</div>'; 
        document.getElementById('rows').innerHTML = ''; 
        document.getElementById('topList').innerHTML = ''; 
        return; 
      }
      
      const totalPlayers = list.length; 
      const totalSessions = list.reduce((a, p) => a + (p.sessions || 0), 0); 
      const bestGlobal = list.reduce((m, p) => Math.max(m, p.best || 0), 0); 
      const totalFood = list.reduce((a, p) => a + (p.totalFood || 0), 0);
      const avgPointsPerSec = (list.reduce((a, p) => a + (parseFloat(p.pointsPerSec) || 0), 0) / Math.max(1, totalPlayers)).toFixed(2);
      const avgFoodPerMin = (list.reduce((a, p) => a + (parseFloat(p.foodPerMin) || 0), 0) / Math.max(1, totalPlayers)).toFixed(2);
      
      kpis.innerHTML = `
        <div class="kpi"><div style="color:var(--muted)">Total jugadores</div><div style="font-weight:800">${totalPlayers}</div></div>
        <div class="kpi"><div style="color:var(--muted)">Partidas totales</div><div style="font-weight:800">${totalSessions}</div></div>
        <div class="kpi"><div style="color:var(--muted)">Mejor global</div><div style="font-weight:800">${bestGlobal}</div></div>
        <div class="kpi"><div style="color:var(--muted)">Puntos/segundo</div><div style="font-weight:800">${avgPointsPerSec}</div></div>
      `;
      
      // tabla
      const tbody = document.getElementById('rows'); 
      tbody.innerHTML = ''; 
      list.sort((a, b) => (b.best || 0) - (a.best || 0)); 
      
      list.forEach(p => { 
        const avg = p.scores && p.scores.length ? (p.scores.reduce((a, b) => a + b, 0) / p.scores.length).toFixed(1) : '—';
        
        const tr = document.createElement('tr'); 
        tr.innerHTML = `
          <td>${escapeHtml(p.name)}</td>
          <td>${escapeHtml(p.phone)}</td>
          <td>${p.age || '—'}</td>
          <td>${p.best || 0}</td>
          <td>${(p.scores || []).length}</td>
          <td>${p.pointsPerSec || 0}</td>
          <td>${p.totalTime || 0}</td>
          <td>${p.totalFood || 0}</td>
          <td>${p.last ? new Date(p.last).toLocaleString() : '—'}</td>
        `; 
        tbody.appendChild(tr); 
      });
      
      // edad chart
      const ageCounts = {}; 
      list.forEach(p => { 
        if(p.age) ageCounts[p.age] = (ageCounts[p.age] || 0) + 1; 
      }); 
      
      const ageLabels = Object.keys(ageCounts).sort((a, b) => a - b); 
      const ageValues = ageLabels.map(age => ageCounts[age]);
      drawBarChart('ageChart', ageLabels, ageValues, 'Edades', 'Jugadores');
      
      // top list
      const top = [];
      list.forEach(p => { 
        if(p.scores) p.scores.forEach(s => top.push({name: p.name, score: s})); 
      }); 
      
      top.sort((a, b) => b.score - a.score); 
      const topList = document.getElementById('topList'); 
      topList.innerHTML = ''; 
      
      top.slice(0, 5).forEach(t => { 
        const li = document.createElement('li'); 
        li.textContent = `${t.name} — ${t.score}`; 
        topList.appendChild(li); 
      });
      
      // Nueva gráfica de distribución de puntajes
      const scoreRanges = {'0-100': 0, '101-200': 0, '201-300': 0, '301-400': 0, '401+': 0};
      list.forEach(p => {
        if(p.scores) {
          p.scores.forEach(score => {
            if(score <= 100) scoreRanges['0-100']++;
            else if(score <= 200) scoreRanges['101-200']++;
            else if(score <= 300) scoreRanges['201-300']++;
            else if(score <= 400) scoreRanges['301-400']++;
            else scoreRanges['401+']++;
          });
        }
      });
      
      drawBarChart('scoreChart', Object.keys(scoreRanges), Object.values(scoreRanges), 'Rangos de puntaje', 'Cantidad');
      
      // Gráfica de comidas por minuto
      const ageFoodRates = {};
      list.forEach(p => {
        if(p.age && p.foodPerMin) {
          if(!ageFoodRates[p.age]) ageFoodRates[p.age] = {total: 0, count: 0};
          ageFoodRates[p.age].total += parseFloat(p.foodPerMin);
          ageFoodRates[p.age].count++;
        }
      });
      
      const ageFoodLabels = Object.keys(ageFoodRates).sort((a, b) => a - b);
      const ageFoodValues = ageFoodLabels.map(age => (ageFoodRates[age].total / ageFoodRates[age].count).toFixed(2));
      
      drawBarChart('foodPerMinChart', ageFoodLabels, ageFoodValues, 'Edad', 'Comidas/minuto');
      
      // Gráfica de eficiencia (puntaje/tiempo) por grupo de edad
      const ageEfficiency = {};
      list.forEach(p => {
        if(p.age && p.pointsPerSec) {
          if(!ageEfficiency[p.age]) ageEfficiency[p.age] = {total: 0, count: 0};
          ageEfficiency[p.age].total += parseFloat(p.pointsPerSec);
          ageEfficiency[p.age].count++;
        }
      });
      
      const efficiencyLabels = Object.keys(ageEfficiency).sort((a, b) => a - b);
      const efficiencyValues = efficiencyLabels.map(age => (ageEfficiency[age].total / ageEfficiency[age].count).toFixed(2));
      
      drawLineChart('efficiencyChart', efficiencyLabels, efficiencyValues, 'Edad', 'Puntos/segundo');
      
      // Gráfica de duración de partidas
      const durations = list.map(p => p.totalTime / (p.sessions || 1)).filter(t => t > 0);
      const durationRanges = {'0-30': 0, '31-60': 0, '61-120': 0, '121-300': 0, '301+': 0};
      
      durations.forEach(duration => {
        if(duration <= 30) durationRanges['0-30']++;
        else if(duration <= 60) durationRanges['31-60']++;
        else if(duration <= 120) durationRanges['61-120']++;
        else if(duration <= 300) durationRanges['121-300']++;
        else durationRanges['301+']++;
      });
      
      drawBarChart('durationChart', Object.keys(durationRanges), Object.values(durationRanges), 'Duración (segundos)', 'Partidas');
    }

    function drawBarChart(id, labels, values, xLabel = '', yLabel = ''){ 
      const c = document.getElementById(id); 
      const ctx = c.getContext('2d'); 
      ctx.clearRect(0, 0, c.width, c.height); 
      
      const pad = {l: 28, r: 12, t: 8, b: 28}; 
      const W = c.width, H = c.height;
      const max = Math.max(1, ...values); 
      const bw = (W - pad.l - pad.r) / values.length - 8; 
      
      ctx.fillStyle = 'rgba(255,255,255,0.9)'; 
      ctx.font = '12px system-ui'; 
      
      for(let i = 0; i < values.length; i++){ 
        const v = values[i]; 
        const h = (v / max) * (H - pad.t - pad.b); 
        const x0 = pad.l + i * (bw + 8) + 4; 
        const y0 = H - pad.b - h; 
        
        const g = ctx.createLinearGradient(0, y0, 0, H - pad.b); 
        g.addColorStop(0, 'rgba(37, 99, 235, 0.95)'); 
        g.addColorStop(1, 'rgba(59, 130, 246, 0.35)'); 
        
        ctx.fillStyle = g; 
        ctx.fillRect(x0, y0, bw, h); 
        ctx.fillStyle = 'rgba(229,231,235,0.9)'; 
        ctx.textAlign = 'center'; 
        ctx.fillText(labels[i], x0 + bw / 2, H - 8); 
        ctx.fillText(values[i], x0 + bw / 2, y0 - 6); 
      }
      
      // Ejes y etiquetas
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.textAlign = 'center';
      ctx.fillText(xLabel, W / 2, H - 5);
      
      ctx.save();
      ctx.translate(10, H / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();
    }
    
    function drawLineChart(id, labels, values, xLabel = '', yLabel = '') {
      const c = document.getElementById(id);
      const ctx = c.getContext('2d');
      ctx.clearRect(0, 0, c.width, c.height);
      
      const pad = {l: 28, r: 12, t: 8, b: 28};
      const W = c.width, H = c.height;
      const max = Math.max(1, ...values);
      
      // Draw line
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(37, 99, 235, 0.8)';
      ctx.lineWidth = 2;
      
      for(let i = 0; i < values.length; i++) {
        const x = pad.l + i * ((W - pad.l - pad.r) / (values.length - 1));
        const y = H - pad.b - (values[i] / max) * (H - pad.t - pad.b);
        
        if(i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
        
        // Draw points
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(37, 99, 235, 0.95)';
        ctx.fill();
      }
      
      ctx.stroke();
      
      // Draw labels
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.textAlign = 'center';
      ctx.font = '12px system-ui';
      
      for(let i = 0; i < labels.length; i++) {
        const x = pad.l + i * ((W - pad.l - pad.r) / (labels.length - 1));
        ctx.fillText(labels[i], x, H - 8);
        ctx.fillText(values[i], x, H - pad.b - (values[i] / max) * (H - pad.t - pad.b) - 10);
      }
      
      // Axis labels
      ctx.fillText(xLabel, W / 2, H - 5);
      
      ctx.save();
      ctx.translate(10, H / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();
    }

    function escapeHtml(s){ 
      return (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#039;'}[c])); 
    }

    // helper: load and save
    function load(){ try{ return JSON.parse(localStorage.getItem(LS)) || []; } catch{ return []; } }

    // reassign players reference
    players = load();

    // Dibujar el juego inicialmente
    draw();

  </script>
</body>
</html>
