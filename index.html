<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=0.8, user-scalable=yes" />
  <title>ethernAI ‚Äî Demo</title>
  <style>
    :root{--bg:#0b0f17;--panel:#0f1720;--accent:#19c2ff;--accent2:#7c3aed;--text:#e6eef6;--muted:#94a3b8;--radius:14px}
    *{box-sizing:border-box} body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:radial-gradient(circle at 10% 10%,#07101a, #08121a 40%,var(--bg));color:var(--text);touch-action:manipulation;overflow-x:auto; min-height:100vh}
    header{position:sticky;top:0;background:rgba(6,8,12,.64);backdrop-filter:blur(6px);border-bottom:1px solid rgba(255,255,255,.03);z-index:10}
    .container{max-width:1100px;margin:0 auto;padding:20px}
    .nav{display:flex;align-items:center;gap:12px}
    .brand{display:flex;gap:12px;align-items:center}
    .logo {
        width: 140px;
        height: 60px;
        border-radius: 10px;
        background-image: url('https://raw.githubusercontent.com/Antoin3e/E3thernAI/main/ETHERNAILOGO.png');
        background-size: cover;
        background-position: center;
        box-shadow: 0 6px 26px rgba(25, 194, 255, .12);
    }
    .tabs{margin-left:auto;display:flex;gap:8px}
    .tab{background:transparent;border:0;padding:8px 12px;color:var(--muted);cursor:pointer;border-radius:10px;font-weight:700}
    .tab.active{color:var(--text);background:linear-gradient(180deg,rgba(25,194,255,.06),rgba(25,194,255,.03))}
    main{padding:20px}
    .panel{display:none;background:linear-gradient(180deg, rgba(255,255,255,.01), rgba(255,255,255,0));border:1px solid rgba(255,255,255,.03); border-radius:var(--radius); padding:18px; box-shadow:0 10px 30px rgba(0,0,0,.45)}
    .panel.active{display:block}

    /* Game layout */
    .game-wrap{display:grid;grid-template-columns:1fr;gap:16px}
    @media(max-width:980px){
      .game-wrap{grid-template-columns:1fr}
      .tabs{display:none}
      .mobile-tabs{display:flex;justify-content:space-around;margin:20px 0;background:rgba(255,255,255,.02);border-radius:12px;padding:8px}
      .mobile-tab{color:var(--muted);padding:10px;text-align:center;flex:1;font-weight:700}
      .mobile-tab.active{color:var(--text);background:linear-gradient(180deg,rgba(25,194,255,.06),rgba(25,194,255,.03));border-radius:8px}
      
      /* Ajustes para m√≥vil */
      #panel-datos, #panel-catalogo {
        transform: scale(0.95);
        transform-origin: top center;
        width: 100%;
        margin-left: 0;
        overflow-x: auto;
      }
      
      /* Permitir zoom y desplazamiento en m√≥viles */
      body {
        touch-action: manipulation;
        overflow-x: auto;
      }
      
      .container, main {
        width: 100%;
        max-width: 100%;
        overflow-x: auto;
      }
    }
    @media(max-width:768px){
      .container{padding:10px}
      main{padding:10px}
      .kpis{grid-template-columns:repeat(2,1fr) !important}
      .catalog{grid-template-columns:1fr !important}
      .data-grid{grid-template-columns:1fr !important}
      
      /* Ajustes adicionales para m√≥viles peque√±os */
      #panel-datos, #panel-catalogo {
        transform: scale(0.9);
        width: 110%;
        margin-left: -5%;
      }
      
      /* Mejorar visualizaci√≥n de tablas en m√≥vil */
      table {
        font-size: 12px;
      }
      
      th, td {
        padding: 6px 4px;
      }
    }
    @media(min-width:981px){
      .mobile-tabs{display:none}
    }
    canvas#game{width:100%;height:480px;border-radius:12px;background:linear-gradient(180deg,#071425,#07101a);display:block}
    .hud{display:none} /* Ocultamos el panel lateral */
    .stat{display:flex;justify-content:space-between;padding:8px 10px;border-radius:8px;background:rgba(255,255,255,.02);margin-bottom:8px}
    .btn{appearance:none;border:0;padding:10px 12px;border-radius:10px;background:linear-gradient(180deg,var(--accent),var(--accent2));color:#041018;font-weight:800;cursor:pointer}
    .btn-secondary{appearance:none;border:0;padding:10px 12px;border-radius:10px;background:linear-gradient(180deg, #ff6b6b, #ee5a24);color:white;font-weight:800;cursor:pointer;margin-top:10px}

    /* Registration overlay */
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:5;background:rgba(6,8,12,.85)}
    .card{background:var(--panel);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,.04);min-width:320px;max-width:90vw}
    .field{display:flex;flex-direction:column;margin-bottom:10px}
    .field input{padding:10px;border-radius:8px;background:#071018;border:1px solid rgba(255,255,255,.03);color:var(--text)}

    /* Data */
    .kpis{display:grid;grid-template-columns:repeat(4,1fr);gap:12px;margin-bottom:12px}
    .kpi{background:rgba(255,255,255,.02);padding:10px;border-radius:10px;text-align:center}
    table{width:100%;border-collapse:collapse;border-radius:10px;overflow:hidden}
    th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,.03);text-align:left}
    .data-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-top:12px}
    .charts-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-top:20px}
    .full-width{grid-column:1/-1}

    /* Catalog */
    .catalog{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    .cat{background:linear-gradient(180deg,rgba(25,194,255,.04),rgba(124,58,237,.03));padding:12px;border-radius:12px;cursor:pointer}
    .contact{margin-top:10px;padding:8px;background:rgba(0,0,0,.3);border-radius:8px;border:1px solid rgba(255,255,255,.03)}

    /* Joystick */
    #joystick-container{position:absolute;bottom:20px;left:20px;width:120px;height:120px;z-index:4;display:none}
    #joystick{width:100%;height:100%;border-radius:50%;background:rgba(25,194,255,0.1);border:1px solid rgba(255,255,255,0.1);position:relative}
    #joystick-handle{width:40px;height:40px;border-radius:50%;background:linear-gradient(180deg,var(--accent),var(--accent2));position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);touch-action:none}

    /* Bot√≥n de men√∫ para m√≥vil */
    .mobile-menu-btn{display:none;background:transparent;border:none;color:var(--muted);font-size:24px;cursor:pointer;padding:5px}
    @media(max-width:980px){
      .mobile-menu-btn{display:block}
      .tabs{display:none;position:absolute;top:100%;right:0;background:rgba(6,8,12,.9);backdrop-filter:blur(6px);flex-direction:column;width:200px;border-radius:12px;padding:10px;border:1px solid rgba(255,255,255,.03);z-index:10}
      .tabs.active{display:flex}
      .tab{width:100%;text-align:left;margin-bottom:5px}
    }
    
    /* Mejoras para visualizaci√≥n en m√≥vil */
    .mobile-optimized {
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }
    
    /* Permitir zoom en contenido */
    .zoomable {
      max-width: 100%;
      overflow: auto;
    }
    
    /* Mini HUD dentro del juego */
    .mini-hud {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: bold;
      z-index: 3;
    }
  </style>
</head>
<body class="mobile-optimized">
  <header>
    <div class="container nav">
      <div class="brand"><div class="logo"></div><div>
        <div style="font-weight:800">ethernAI</div>
        <div style="font-size:12px;color:var(--muted)">Soluciones Industria 4.0 ¬∑ IA ¬∑ Big Data</div>
      </div></div>
      <button class="mobile-menu-btn">‚ò∞</button>
      <div class="tabs">
        <button class="tab active" data-tab="jugar">Jugar</button>
        <button class="tab" data-tab="datos">Datos</button>
        <button class="tab" data-tab="catalogo">Cat√°logo</button>
      </div>
    </div>
  </header>

  <main class="container zoomable">
    <!-- Mobile tabs -->
    <div class="mobile-tabs">
      <div class="mobile-tab active" data-tab="jugar">Jugar</div>
      <div class="mobile-tab" data-tab="datos">Datos</div>
      <div class="mobile-tab" data-tab="catalogo">Cat√°logo</div>
    </div>

    <!-- JUGAR -->
    <section id="panel-jugar" class="panel active">
      <h1>JUEGA: ¬°QUE NO TE ALCANCE!</h1>
      <p style="color:var(--muted)">Controla la gota (WASD / flechas) o inclina tu m√≥vil. Recolecta orbes y no dejes que la llama te alcance.</p>

      <div class="game-wrap">
        <div style="position:relative">
          <canvas id="game" width="900" height="480"></canvas>
          
          <!-- Mini HUD dentro del juego -->
          <div class="mini-hud">
            Puntaje: <span id="mini-score">0</span>
          </div>
          
          <!-- Joystick para m√≥vil -->
          <div id="joystick-container">
            <div id="joystick">
              <div id="joystick-handle"></div>
            </div>
          </div>

          <div id="overlayReg" class="overlay">
            <div class="card">
              <h2>Registrate para comenzar</h2>
              <p class="note" style="color:var(--muted);margin:6px 0">Antes de cada partida registra Nombre, Tel√©fono y Edad.</p>
              <div class="field"><label>Nombre</label><input id="name" placeholder="Tu nombre" maxlength="40"></div>
              <div class="field"><label>Tel√©fono</label><input id="phone" placeholder="Ingresa tu numero de telefono" maxlength="20" inputmode="tel"></div>
              <div class="field"><label>Edad</label><input id="age" type="number" min="5" max="120"></div>
              <div style="display:flex;gap:8px;margin-top:6px;align-items:center;flex-wrap:wrap">
                <button id="btnStart" class="btn">Comenzar</button>
                <button id="btnGyro" class="btn" style="background:linear-gradient(180deg,#fff3 10%,rgba(255,255,255,.02));color:var(--text);font-weight:700">Permitir Giroscopio</button>
              </div>
              <p style="font-size:12px;color:var(--muted);margin-top:8px">Los datos se guardan localmente en tu navegador.</p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- DATOS -->
    <section id="panel-datos" class="panel">
      <h1>Dashboard de jugadores</h1>
      <div class="kpis" id="kpis"></div>

      <div class="data-grid">
        <div>
          <table>
            <thead><tr><th>Nombre</th><th>Tel√©fono</th><th>Edad</th><th>Mejor</th><th>Partidas</th><th>Promedio</th><th>Tiempo(s)</th><th>Orbes/s</th><th>√öltima</th></tr></thead>
            <tbody id="rows"></tbody>
          </table>
        </div>
        <div style="background:rgba(255,255,255,.02);padding:12px;border-radius:10px">
          <h3 style="margin:0 0 8px">Distribuci√≥n de edades</h3>
          <canvas id="ageChart" width="380" height="260"></canvas>
          <h3 style="margin-top:12px">Top 5 mejores puntajes</h3>
          <ol id="topList" style="color:var(--muted)"></ol>
        </div>
      </div>

      <div class="charts-grid">
        <div style="background:rgba(255,255,255,.02);padding:12px;border-radius:10px">
          <h3 style="margin:0 0 8px">Distribuci√≥n de puntajes</h3>
          <canvas id="scoreChart" width="380" height="260"></canvas>
        </div>
        <div style="background:rgba(255,255,255,.02);padding:12px;border-radius:10px">
          <h3 style="margin:0 0 8px">Tiempo promedio por orbe (segundos)</h3>
          <canvas id="timePerOrbChart" width="380" height="260"></canvas>
        </div>
      </div>

      <div class="charts-grid">
        <div style="background:rgba(255,255,255,.02);padding:12px;border-radius:10px">
          <h3 style="margin:0 0 8px">Eficiencia por grupo de edad</h3>
          <canvas id="efficiencyChart" width="380" height="260"></canvas>
        </div>
        <div style="background:rgba(255,255,255,.02);padding:12px;border-radius:10px">
          <h3 style="margin:0 0 8px">Distribuci√≥n de sesiones por jugador</h3>
          <canvas id="sessionsChart" width="380" height="260"></canvas>
        </div>
      </div>

      <div style="margin-top:20px;text-align:center">
        <button id="clearDataBtn" class="btn-secondary">üóëÔ∏è Limpiar todos los datos</button>
        <p style="color:var(--muted);font-size:12px;margin-top:8px">Esta acci√≥n eliminar√° todos los registros de jugadores y no se puede deshacer.</p>
      </div>
    </section>

    <!-- CATALOGO -->
    <section id="panel-catalogo" class="panel">
      <h1>Cat√°logo de soluciones</h1>
      <p style="color:var(--muted)">Presiona una tarjeta para ver nuestro contacto.</p>
      <div class="catalog">
        <div class="cat" data-title="Optimizaci√≥n de flujos" onclick="showContact(this)">
          <h3>Optimizaci√≥n de flujos operativos</h3>
          <p style="color:var(--muted)">Mapeo, automatizaci√≥n y reducci√≥n de tiempos ciclo.</p>
        </div>
        <div class="cat" data-title="Inventarios" onclick="showContact(this)">
          <h3>Gesti√≥n inteligente de inventarios</h3>
          <p style="color:var(--muted)">Forecasting con IA para disminuir faltantes y sobrestock.</p>
        </div>
        <div class="cat" data-title="Mantenimiento" onclick="showContact(this)">
          <h3>Mantenimiento predictivo</h3>
          <p style="color:var(--muted)">Modelos de falla y monitoreo de condici√≥n.</p>
        </div>
        <div class="cat" data-title="Analitica" onclick="showContact(this)">
          <h3>Anal√≠tica y dashboards</h3>
          <p style="color:var(--muted)">Dashboards accionables y DataOps.</p>
        </div>
        <div class="cat" data-title="Automatizacion" onclick="showContact(this)">
          <h3>Automatizaci√≥n documental</h3>
          <p style="color:var(--muted)">OCR –∏ workflows sin papel.</p>
        </div>
        <div class="cat" data-title="Integracion" onclick="showContact(this)">
          <h3>Integraci√≥n de datos</h3>
          <p style="color:var(--muted)">Conexi√≥n de fuentes y APIs para BI.</p>
        </div>
      </div>
    </section>

  </main>

  <script>
    /* ===== Navegaci√≥n de pesta√±as ===== */
    const tabs = document.querySelectorAll('.tab');
    const mobileTabs = document.querySelectorAll('.mobile-tab');
    const panels = {jugar:document.getElementById('panel-jugar'), datos:document.getElementById('panel-datos'), catalogo:document.getElementById('panel-catalogo')};
    const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
    const clearDataBtn = document.getElementById('clearDataBtn');
    const miniScoreEl = document.getElementById('mini-score');
    
    function activateTab(tabName) {
      tabs.forEach(b => b.classList.remove('active'));
      mobileTabs.forEach(b => b.classList.remove('active'));
      document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');
      document.querySelector(`.mobile-tab[data-tab="${tabName}"]`).classList.add('active');
      
      Object.values(panels).forEach(p => p.classList.remove('active'));
      panels[tabName].classList.add('active');
      
      // Cerrar men√∫ m√≥vil si est√° abierto
      document.querySelector('.tabs').classList.remove('active');
      
      if(tabName === 'datos') renderDashboard();
    }
    
    tabs.forEach(t => t.addEventListener('click', () => activateTab(t.dataset.tab)));
    mobileTabs.forEach(t => t.addEventListener('click', () => activateTab(t.dataset.tab)));
    
    // Toggle men√∫ m√≥vil
    mobileMenuBtn.addEventListener('click', () => {
      document.querySelector('.tabs').classList.toggle('active');
    });

    // Cerrar men√∫ al hacer clic fuera
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.tabs') && !e.target.closest('.mobile-menu-btn')) {
        document.querySelector('.tabs').classList.remove('active');
      }
    });

    /* ===== Persistencia ===== */
    const LS = 'ethernai_players_v1';
    function load(){ try{return JSON.parse(localStorage.getItem(LS))||[];}catch{return [];} }
    function save(data){ localStorage.setItem(LS, JSON.stringify(data)); }

    // Limpiar datos
    clearDataBtn.addEventListener('click', () => {
      if(confirm('¬øEst√°s seguro de que quieres eliminar todos los datos? Esta acci√≥n no se puede deshacer.')) {
        localStorage.removeItem(LS);
        players = [];
        renderDashboard();
        alert('Todos los datos han sido eliminados.');
      }
    });

    /* ====== Juego (canvas) ====== */
    const canvas = document.getElementById('game'); 
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlayReg');
    const nameIn = document.getElementById('name'); 
    const phoneIn = document.getElementById('phone'); 
    const ageIn = document.getElementById('age');
    const btnStart = document.getElementById('btnStart'); 
    const btnGyro = document.getElementById('btnGyro');

    let players = load(); 
    let current = null; 
    let running = false; 
    let raf = null; 
    let world = {w: canvas.width, h: canvas.height};
    
    // Mejoras visuales para la gota y llama
    let player = {
      x: 120, y: 120, r: 14, speed: 3.2,
      trail: [] // Para efecto de estela
    }; 
    
    let flame = {
      x: world.w-140, y: world.h-120, r: 18, speed: 2.6,
      particles: [] // Para efecto de part√≠culas de fuego
    }; 
    
    let orbs = []; 
    let obstacles = [];
    let keys = {}; 
    let score = 0; 
    let best = 0; 
    let startTime = 0; 
    let sessionCounted = false;
    let gyroEnabled = false; 
    let tiltX = 0; 
    let joystickActive = false; 
    let joystickX = 0; 
    let joystickY = 0;
    
    // Para estad√≠sticas de tiempo por orbe
    let orbCollectionTimes = [];
    let lastOrbCollectionTime = 0;

    // Detectar dispositivo m√≥vil
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    if (isMobile) {
      joystickContainer.style.display = 'block';
    }

    // Inicializar joystick
    function initJoystick() {
      const joystick = document.getElementById('joystick');
      const handle = document.getElementById('joystick-handle');
      const joystickSize = joystick.offsetWidth;
      const handleSize = handle.offsetWidth;
      const maxDistance = (joystickSize - handleSize) / 2;

      let touchId = null;

      handle.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchId = e.changedTouches[0].identifier;
        joystickActive = true;
      });

      document.addEventListener('touchmove', (e) => {
        if (!joystickActive) return;
        
        const touch = Array.from(e.changedTouches).find(t => t.identifier === touchId);
        if (!touch) return;
        
        const rect = joystick.getBoundingClientRect();
        const centerX = rect.left + joystickSize / 2;
        const centerY = rect.top + joystickSize / 2;
        
        let x = touch.clientX - centerX;
        let y = touch.clientY - centerY;
        
        // Limitar el movimiento al √°rea del joystick
        const distance = Math.min(maxDistance, Math.sqrt(x * x + y * y));
        const angle = Math.atan2(y, x);
        
        x = Math.cos(angle) * distance;
        y = Math.sin(angle) * distance;
        
        // Actualizar posici√≥n del handle
        handle.style.transform = `translate(${x}px, ${y}px)`;
        
        // Calcular valores normalizados para el movimiento
        joystickX = x / maxDistance;
        joystickY = y / maxDistance;
      });

      document.addEventListener('touchend', (e) => {
        if (!joystickActive) return;
        
        const touch = Array.from(e.changedTouches).find(t => t.identifier === touchId);
        if (!touch) return;
        
        // Resetear joystick
        handle.style.transform = 'translate(-50%, -50%)';
        joystickX = 0;
        joystickY = 0;
        joystickActive = false;
        touchId = null;
      });
    }

    // controles teclado - FIXED: Ahora permite escribir WASD en los campos de texto
    window.addEventListener('keydown', e => { 
      // Solo capturar teclas de movimiento si no estamos en un campo de texto
      if (!['INPUT', 'TEXTAREA'].includes(e.target.tagName) && 
          ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyW','KeyA','KeyS','KeyD'].includes(e.code)) { 
        keys[e.code] = true; 
        e.preventDefault(); 
      }
    });
    
    window.addEventListener('keyup', e => { 
      if (keys[e.code] !== undefined) { 
        keys[e.code] = false; 
        if (!['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
          e.preventDefault(); 
        }
      }
    });

    // giroscopio (movimiento lateral)
    btnGyro.addEventListener('click', async ()=>{
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission === 'granted') {
            window.addEventListener('deviceorientation', onDeviceOrientation);
            gyroEnabled = true;
            alert('Giroscopio activado. Inclina tu dispositivo para mover la gota.');
          } else {
            alert('Permiso para usar el giroscopio denegado.');
          }
        } catch (error) {
          alert('Error al solicitar permiso para el giroscopio: ' + error.message);
        }
      } else if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', onDeviceOrientation);
        gyroEnabled = true;
        alert('Giroscopio activado. Inclina tu dispositivo para mover la gota.');
      } else {
        alert('Tu dispositivo no soporta el API de orientaci√≥n o no est√° disponible.');
      }
    });

    function onDeviceOrientation(e) {
      // Gamma es la inclinaci√≥n izquierda-derecha
      if (e.gamma !== null) {
        // Limitar la inclinaci√≥n a un rango de -45 a 45 grados y normalizar a -1 a 1
        tiltX = Math.max(-45, Math.min(45, e.gamma)) / 45;
      }
    }

    function spawnOrbs(n=6){ 
      orbs.length = 0; 
      for(let i = 0; i < n; i++) { 
        orbs.push({
          x: 60 + Math.random() * (world.w - 120),
          y: 60 + Math.random() * (world.h - 120),
          r: 8,
          alive: true,
          pulse: 0
        }); 
      }
    }

    function spawnObstacles(){ obstacles = []; }

    function resetWorld(){ 
      player.x = 120; 
      player.y = 120; 
      player.trail = [];
      flame.x = world.w - 140; 
      flame.y = world.h - 120; 
      flame.particles = [];
      score = 0; 
      miniScoreEl.textContent = 0; 
      spawnOrbs(); 
      spawnObstacles(); 
      best = (current && current.best) ? current.best : 0; 
      orbCollectionTimes = [];
      lastOrbCollectionTime = Date.now();
    }

    // CORRECCI√ìN: A√±adir event listener al bot√≥n de comenzar
    btnStart.addEventListener('click', ()=>{
      const name = nameIn.value.trim(); 
      const phone = phoneIn.value.trim(); 
      const age = parseInt(ageIn.value,10);
      if(!name || !phone || !age || age < 5 || age > 120){ 
        alert('Ingresa nombre, tel√©fono y edad v√°lidos.'); 
        return; 
      }
      current = {
        name, 
        phone, 
        age, 
        sessions: 0, 
        best: 0, 
        totalTime: 0, 
        orbTimes: [],
        last: new Date().toISOString()
      };
      overlay.style.display = 'none'; 
      resetWorld(); 
      startGame();
    });

    function startGame(){ 
      if(running) return; 
      running = true; 
      startTime = Date.now(); 
      lastOrbCollectionTime = Date.now();
      sessionCounted = true; 
      loop(); 
    }

    function endGame(justReset = false){ 
      running = false; 
      cancelAnimationFrame(raf); 
      raf = null; 
      const timeSec = Math.floor((Date.now() - startTime) / 1000);
      
      // guardar datos
      if(current){ 
        current.sessions = (current.sessions || 0) + 1; 
        current.totalTime = (current.totalTime || 0) + timeSec; 
        current.last = new Date().toISOString(); 
        
        // Guardar tiempos de orbes si hay datos
        if (orbCollectionTimes.length > 0) {
          current.orbTimes = current.orbTimes || [];
          current.orbTimes.push({
            session: current.sessions,
            average: orbCollectionTimes.reduce((a, b) => a + b, 0) / orbCollectionTimes.length,
            values: [...orbCollectionTimes]
          });
        }
        
        if(score > (current.best || 0)){ 
          current.best = score; 
        }
        
        // merge into players
        const idx = players.findIndex(p => 
          p.name.toLowerCase() === current.name.toLowerCase() && p.phone === current.phone
        );
        
        if(idx >= 0){ 
          const p = players[idx]; 
          p.sessions = current.sessions; 
          p.totalTime = current.totalTime; 
          p.best = Math.max(p.best || 0, current.best); 
          p.scores = p.scores || []; 
          p.scores.push(score); 
          p.last = current.last;
          p.orbTimes = current.orbTimes;
        } else { 
          current.scores = [score]; 
          players.push(current); 
        }
        
        save(players);
      }
      
      // mostrar popup resumen si no es solo reinicio
      if(!justReset){ 
        const timePerOrb = orbCollectionTimes.length > 0 
          ? (orbCollectionTimes.reduce((a, b) => a + b, 0) / orbCollectionTimes.length).toFixed(2) 
          : "N/A";
        alert(`Partida finalizada. Puntaje: ${score} ‚Äî Tiempo: ${timeSec}s\nTiempo promedio por orbe: ${timePerOrb}s`);
      }
      
      // exigir re-registro para jugar otra vez
      overlay.style.display = 'flex'; 
      current = null;
    }

    function loop(){ 
      update(); 
      draw(); 
      if(running) raf = requestAnimationFrame(loop); 
    }

    function update(){ 
      // movimiento jugador por teclado, gyro o joystick
      let dx = 0, dy = 0;
      
      // Controles de teclado
      dx = (keys.KeyD || keys.ArrowRight ? 1 : 0) - (keys.KeyA || keys.ArrowLeft ? 1 : 0);
      dy = (keys.KeyS || keys.ArrowDown ? 1 : 0) - (keys.KeyW || keys.ArrowUp ? 1 : 0);
      
      // Controles de giroscopio
      if(gyroEnabled){ 
        dx += tiltX;
      }
      
      // Controles de joystick (m√≥vil)
      if (joystickActive) {
        dx += joystickX;
        dy += joystickY;
      }
      
      const len = Math.hypot(dx, dy) || 1; 
      player.x += (dx / len) * player.speed; 
      player.y += (dy / len) * player.speed;
      
      // Guardar posici√≥n para la estela
      player.trail.push({x: player.x, y: player.y});
      if (player.trail.length > 10) player.trail.shift();
      
      player.x = Math.max(player.r, Math.min(world.w - player.r, player.x)); 
      player.y = Math.max(player.r, Math.min(world.h - player.r, player.y));
      
      // llama persigue
      const fx = player.x - flame.x; 
      const fy = player.y - flame.y; 
      const fl = Math.hypot(fx, fy) || 1; 
      flame.x += (fx / fl) * flame.speed; 
      flame.y += (fy / fl) * flame.speed;
      
      // Generar part√≠culas de fuego
      if (Math.random() < 0.3) {
        flame.particles.push({
          x: flame.x + (Math.random() - 0.5) * 10,
          y: flame.y + (Math.random() - 0.5) * 10,
          size: Math.random() * 3 + 1,
          life: 20
        });
      }
      
      // Actualizar part√≠culas
      flame.particles = flame.particles.map(p => {
        p.life--;
        return p;
      }).filter(p => p.life > 0);
      
      // orbes - efecto de pulso
      for(const o of orbs){ 
        if(!o.alive) continue; 
        o.pulse = (o.pulse + 0.05) % (Math.PI * 2);
        
        const d = Math.hypot(player.x - o.x, player.y - o.y); 
        if(d < player.r + o.r){ 
          o.alive = false; 
          score += 10; 
          miniScoreEl.textContent = score;
          
          // Calcular tiempo para agarrar este orbe
          const now = Date.now();
          const timeToCollect = (now - lastOrbCollectionTime) / 1000;
          orbCollectionTimes.push(timeToCollect);
          lastOrbCollectionTime = now;
        }
      }
      
      if(orbs.every(o => !o.alive)) spawnOrbs();
      
      // colision llama (solo esta colisi√≥n hace perder)
      if(Math.hypot(player.x - flame.x, player.y - flame.y) < player.r + flame.r){ 
        endGame(false); 
      }
    }

    function draw(){ 
      ctx.clearRect(0, 0, world.w, world.h);
      
      // grid
      ctx.strokeStyle = 'rgba(25,194,255,0.04)'; 
      ctx.lineWidth = 1; 
      for(let x = 0; x < world.w; x += 40){ 
        ctx.beginPath(); 
        ctx.moveTo(x, 0); 
        ctx.lineTo(x, world.h); 
        ctx.stroke(); 
      }
      
      for(let y = 0; y < world.h; y += 40){ 
        ctx.beginPath(); 
        ctx.moveTo(0, y); 
        ctx.lineTo(world.w, y); 
        ctx.stroke(); 
      }
      
      // Estela de la gota
      for (let i = 0; i < player.trail.length; i++) {
        const point = player.trail[i];
        const alpha = i / player.trail.length * 0.5;
        ctx.beginPath();
        ctx.arc(point.x, point.y, player.r * (i / player.trail.length), 0, Math.PI * 2);
        ctx.fillStyle = `rgba(139, 233, 255, ${alpha})`;
        ctx.fill();
      }
      
      // orbes con efecto de pulso
      for(const o of orbs){ 
        if(!o.alive) continue;
        const pulseSize = o.r + Math.sin(o.pulse) * 2;
        ctx.beginPath();
        ctx.arc(o.x, o.y, pulseSize, 0, Math.PI * 2);
        
        const gradient = ctx.createRadialGradient(o.x, o.y, 0, o.x, o.y, pulseSize);
        gradient.addColorStop(0, 'rgba(25,194,255,0.95)');
        gradient.addColorStop(1, 'rgba(0,200,255,0.35)');
        
        ctx.fillStyle = gradient;
        ctx.fill();
      }
      
      // jugador (gota de agua)
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
      
      const playerGradient = ctx.createRadialGradient(
        player.x - 3, player.y - 3, 0,
        player.x, player.y, player.r
      );
      playerGradient.addColorStop(0, '#8be9ff');
      playerGradient.addColorStop(0.7, '#3498db');
      playerGradient.addColorStop(1, '#2980b9');
      
      ctx.fillStyle = playerGradient;
      ctx.fill();
      
      // Reflejo en la gota
      ctx.beginPath();
      ctx.arc(player.x - 3, player.y - 3, player.r / 3, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.fill();
      
      // llama con part√≠culas
      for (const p of flame.particles) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${20 + Math.random() * 10}, 100%, 60%, ${p.life / 20})`;
        ctx.fill();
      }
      
      ctx.beginPath();
      ctx.arc(flame.x, flame.y, flame.r, 0, Math.PI * 2);
      
      const flameGradient = ctx.createRadialGradient(
        flame.x, flame.y, 0,
        flame.x, flame.y, flame.r
      );
      flameGradient.addColorStop(0, '#ff9d00');
      flameGradient.addColorStop(0.5, '#ff6600');
      flameGradient.addColorStop(1, '#ff3000');
      
      ctx.fillStyle = flameGradient;
      ctx.fill();
    }

    // cat√°logo contact
    window.showContact = function(el){ 
      if(el.querySelector('.contact')) return; 
      const d = document.createElement('div'); 
      d.className = 'contact'; 
      d.innerHTML = 'Tel: <strong>8123836266</strong><br>Email: <strong>thisis.ethernai@gmail.com</strong><br>Instagram: <a href="https://www.instagram.com/ethern_ai?igsh=MTNjc3B1b2RqZGpwNg==" target="_blank">Ethern-ai</a><br>YouTube: <a href="https://www.youtube.com/@Ethern-ai" target="_blank">Ethern-ai</a>'; 
      el.appendChild(d); 
    }

    // Dashboard
    function renderDashboard(){ 
      const list = load(); 
      const kpis = document.getElementById('kpis'); 
      
      if(!list.length){ 
        kpis.innerHTML = '<div style="grid-column:1/-1;color:var(--muted)">No hay registros a√∫n</div>'; 
        document.getElementById('rows').innerHTML = ''; 
        document.getElementById('topList').innerHTML = ''; 
        return; 
      }
      
      const totalPlayers = list.length; 
      const totalSessions = list.reduce((a, p) => a + (p.sessions || 0), 0); 
      const bestGlobal = list.reduce((m, p) => Math.max(m, p.best || 0), 0); 
      const avgScore = (list.reduce((a, p) => a + (p.scores ? p.scores.reduce((x, y) => x + y, 0) : 0), 0) / Math.max(1, totalSessions)).toFixed(1);
      const avgTime = (list.reduce((a, p) => a + (p.totalTime || 0), 0) / Math.max(1, totalSessions)).toFixed(1);
      
      // Calcular tiempo promedio por orbe
      let totalOrbTime = 0;
      let totalOrbCount = 0;
      list.forEach(p => {
        if (p.orbTimes) {
          p.orbTimes.forEach(session => {
            totalOrbTime += session.average * session.values.length;
            totalOrbCount += session.values.length;
          });
        }
      });
      const avgOrbTime = totalOrbCount > 0 ? (totalOrbTime / totalOrbCount).toFixed(2) : 0;
      
      kpis.innerHTML = `
        <div class="kpi"><div style="color:var(--muted)">Total jugadores</div><div style="font-weight:800">${totalPlayers}</div></div>
        <div class="kpi"><div style="color:var(--muted)">Partidas totales</div><div style="font-weight:800">${totalSessions}</div></div>
        <div class="kpi"><div style="color:var(--muted)">Mejor global</div><div style="font-weight:800">${bestGlobal}</div></div>
        <div class="kpi"><div style="color:var(--muted)">Tiempo/orbe</div><div style="font-weight:800">${avgOrbTime}s</div></div>
      `;
      
      // tabla
      const tbody = document.getElementById('rows'); 
      tbody.innerHTML = ''; 
      list.sort((a, b) => (b.best || 0) - (a.best || 0)); 
      
      list.forEach(p => { 
        const avg = p.scores && p.scores.length ? (p.scores.reduce((a, b) => a + b, 0) / p.scores.length).toFixed(1) : '‚Äî';
        
        // Calcular tiempo promedio por orbe para este jugador
        let playerOrbTime = 0;
        let playerOrbCount = 0;
        if (p.orbTimes) {
          p.orbTimes.forEach(session => {
            playerOrbTime += session.average * session.values.length;
            playerOrbCount += session.values.length;
          });
        }
        const playerAvgOrbTime = playerOrbCount > 0 ? (playerOrbTime / playerOrbCount).toFixed(2) : '‚Äî';
        
        const tr = document.createElement('tr'); 
        tr.innerHTML = `
          <td>${escapeHtml(p.name)}</td>
          <td>${escapeHtml(p.phone)}</td>
          <td>${p.age || '‚Äî'}</td>
          <td>${p.best || 0}</td>
          <td>${(p.scores || []).length}</td>
          <td>${avg}</td>
          <td>${p.totalTime || 0}</td>
          <td>${playerAvgOrbTime}</td>
          <td>${p.last ? new Date(p.last).toLocaleString() : '‚Äî'}</td>
        `; 
        tbody.appendChild(tr); 
      });
      
      // edad chart
      const ageCounts = {}; 
      list.forEach(p => { 
        if(p.age) ageCounts[p.age] = (ageCounts[p.age] || 0) + 1; 
      }); 
      
      const ageLabels = Object.keys(ageCounts).sort((a, b) => a - b); 
      const ageValues = ageLabels.map(age => ageCounts[age]);
      drawBarChart('ageChart', ageLabels, ageValues, 'Edades', 'Jugadores');
      
      // top list
      const top = [];
      list.forEach(p => { 
        if(p.scores) p.scores.forEach(s => top.push({name: p.name, score: s})); 
      }); 
      
      top.sort((a, b) => b.score - a.score); 
      const topList = document.getElementById('topList'); 
      topList.innerHTML = ''; 
      
      top.slice(0, 5).forEach(t => { 
        const li = document.createElement('li'); 
        li.textContent = `${t.name} ‚Äî ${t.score}`; 
        topList.appendChild(li); 
      });
      
      // Nueva gr√°fica de distribuci√≥n de puntajes
      const scoreRanges = {'0-100': 0, '101-200': 0, '201-300': 0, '301-400': 0, '401+': 0};
      list.forEach(p => {
        if(p.scores) {
          p.scores.forEach(score => {
            if(score <= 100) scoreRanges['0-100']++;
            else if(score <= 200) scoreRanges['101-200']++;
            else if(score <= 300) scoreRanges['201-300']++;
            else if(score <= 400) scoreRanges['301-400']++;
            else scoreRanges['401+']++;
          });
        }
      });
      
      drawBarChart('scoreChart', Object.keys(scoreRanges), Object.values(scoreRanges), 'Rangos de puntaje', 'Cantidad');
      
      // Gr√°fica de tiempo promedio por orbe
      const ageOrbTimes = {};
      list.forEach(p => {
        if(p.age && p.orbTimes && p.orbTimes.length) {
          let totalTime = 0;
          let totalOrbs = 0;
          p.orbTimes.forEach(session => {
            totalTime += session.average * session.values.length;
            totalOrbs += session.values.length;
          });
          
          if(!ageOrbTimes[p.age]) ageOrbTimes[p.age] = {total: 0, count: 0};
          ageOrbTimes[p.age].total += totalTime / totalOrbs;
          ageOrbTimes[p.age].count++;
        }
      });
      
      const ageOrbLabels = Object.keys(ageOrbTimes).sort((a, b) => a - b);
      const ageOrbValues = ageOrbLabels.map(age => (ageOrbTimes[age].total / ageOrbTimes[age].count).toFixed(2));
      
      drawBarChart('timePerOrbChart', ageOrbLabels, ageOrbValues, 'Edad', 'Tiempo promedio (s)');
      
      // Gr√°fica de eficiencia (puntaje/tiempo) por grupo de edad
      const ageEfficiency = {};
      list.forEach(p => {
        if(p.age && p.scores && p.scores.length && p.totalTime) {
          const totalScore = p.scores.reduce((a, b) => a + b, 0);
          const efficiency = totalScore / p.totalTime;
          
          if(!ageEfficiency[p.age]) ageEfficiency[p.age] = {total: 0, count: 0};
          ageEfficiency[p.age].total += efficiency;
          ageEfficiency[p.age].count++;
        }
      });
      
      const efficiencyLabels = Object.keys(ageEfficiency).sort((a, b) => a - b);
      const efficiencyValues = efficiencyLabels.map(age => (ageEfficiency[age].total / ageEfficiency[age].count).toFixed(2));
      
      drawLineChart('efficiencyChart', efficiencyLabels, efficiencyValues, 'Edad', 'Eficiencia (pts/seg)');
      
      // Gr√°fica de dispersi√≥n de sesiones por jugador
      const sessionCounts = list.map(p => p.sessions || 0).filter(s => s > 0);
      const sessionData = {
        labels: Array.from({length: Math.max(...sessionCounts)}, (_, i) => i + 1),
        values: Array(Math.max(...sessionCounts)).fill(0)
      };
      
      sessionCounts.forEach(count => {
        if (count <= sessionData.values.length) {
          sessionData.values[count - 1]++;
        }
      });
      
      drawBarChart('sessionsChart', sessionData.labels, sessionData.values, 'N√∫mero de sesiones', 'Jugadores');
    }

    function drawBarChart(id, labels, values, xLabel = '', yLabel = ''){ 
      const c = document.getElementById(id); 
      const ctx = c.getContext('2d'); 
      ctx.clearRect(0, 0, c.width, c.height); 
      
      const pad = {l: 28, r: 12, t: 8, b: 28}; 
      const W = c.width, H = c.height;
      const max = Math.max(1, ...values); 
      const bw = (W - pad.l - pad.r) / values.length - 8; 
      
      ctx.fillStyle = 'rgba(255,255,255,0.9)'; 
      ctx.font = '12px system-ui'; 
      
      for(let i = 0; i < values.length; i++){ 
        const v = values[i]; 
        const h = (v / max) * (H - pad.t - pad.b); 
        const x0 = pad.l + i * (bw + 8) + 4; 
        const y0 = H - pad.b - h; 
        
        const g = ctx.createLinearGradient(0, y0, 0, H - pad.b); 
        g.addColorStop(0, 'rgba(25,194,255,0.95)'); 
        g.addColorStop(1, 'rgba(25,194,255,0.35)'); 
        
        ctx.fillStyle = g; 
        ctx.fillRect(x0, y0, bw, h); 
        ctx.fillStyle = 'rgba(229,231,235,0.9)'; 
        ctx.textAlign = 'center'; 
        ctx.fillText(labels[i], x0 + bw / 2, H - 8); 
        ctx.fillText(values[i], x0 + bw / 2, y0 - 6); 
      }
      
      // Ejes y etiquetas
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.textAlign = 'center';
      ctx.fillText(xLabel, W / 2, H - 5);
      
      ctx.save();
      ctx.translate(10, H / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();
    }
    
    function drawLineChart(id, labels, values, xLabel = '', yLabel = '') {
      const c = document.getElementById(id);
      const ctx = c.getContext('2d');
      ctx.clearRect(0, 0, c.width, c.height);
      
      const pad = {l: 28, r: 12, t: 8, b: 28};
      const W = c.width, H = c.height;
      const max = Math.max(1, ...values);
      
      // Draw line
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(25,194,255,0.8)';
      ctx.lineWidth = 2;
      
      for(let i = 0; i < values.length; i++) {
        const x = pad.l + i * ((W - pad.l - pad.r) / (values.length - 1));
        const y = H - pad.b - (values[i] / max) * (H - pad.t - pad.b);
        
        if(i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
        
        // Draw points
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(25,194,255,0.95)';
        ctx.fill();
      }
      
      ctx.stroke();
      
      // Draw labels
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.textAlign = 'center';
      ctx.font = '12px system-ui';
      
      for(let i = 0; i < labels.length; i++) {
        const x = pad.l + i * ((W - pad.l - pad.r) / (labels.length - 1));
        ctx.fillText(labels[i], x, H - 8);
        ctx.fillText(values[i], x, H - pad.b - (values[i] / max) * (H - pad.t - pad.b) - 10);
      }
      
      // Axis labels
      ctx.fillText(xLabel, W / 2, H - 5);
      
      ctx.save();
      ctx.translate(10, H / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();
    }

    function escapeHtml(s){ 
      return (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#039;'}[c])); 
    }

    // helper: load and save
    function load(){ try{ return JSON.parse(localStorage.getItem(LS)) || []; } catch{ return []; } }

    // reassign players reference
    players = load();

    // initial
    spawnOrbs(); 
    spawnObstacles(); 
    renderDashboard();
    
    if (isMobile) {
      initJoystick();
    }

    // make canvas responsive
    window.addEventListener('resize', () => { 
      const r = canvas.getBoundingClientRect(); 
      world.w = canvas.width = r.width; 
      world.h = canvas.height = 480; 
      
      // Redibujar cuando cambia el tama√±o
      draw();
    });

    // expose renderDashboard to tabs
    window.renderDashboard = renderDashboard;

    // Dibujar el juego inicialmente
    draw();

  </script>
</body>
</html>
